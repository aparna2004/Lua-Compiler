// Update the variant type to include strings
using Value = std::variant<int, bool, std::string>;

// Add StringNode class
class StringNode : public Node {
    std::string value;
public:
    StringNode(const std::string& v) : value(v) {}
    
    void print() const override {
        std::cout << "\"" << value << "\"";
    }
    
    Value evaluate() override {
        return value;
    }
    
    ICResult generateIC() override {
        std::string temp = newTemp();
        return {temp, {temp + " = \"" + value + "\""}};
    }
};

lex
    // Add to the rules section
\"[^\"]*\"  { 
    std::string str = yytext;
// Remove the quotes
str = str.substr(1, str.length() - 2);
yylval.strVal = strdup(str.c_str());
return STRING;
}

parser

        // Add to the token declarations
        % token<strVal> STRING

              // Update the expr rule
              expr : // ...existing rules...
                     | STRING
{
    $$ = new StringNode($1);
};

ast cpp

Value PrintNode::evaluate()
{
    Value val = expr->evaluate();
    if (std::holds_alternative<std::string>(val))
    {
        std::cout << std::get<std::string>(val) << std::endl;
    }
    else if (std::holds_alternative<int>(val))
    {
        std::cout << std::get<int>(val) << std::endl;
    }
    else if (std::holds_alternative<bool>(val))
    {
        std::cout << (std::get<bool>(val) ? "true" : "false") << std::endl;
    }
    return val;
}